Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Кафедра програмної інженерії



Звіт
з практичної роботи №2
З дисципліни «Аналіз та рефакторинг коду»
на тему «Методи рефакторингу коду програмного забезпечення:
Replace Nested Conditional with Guard Clauses, Decompose Conditional, Replace Temp with Query»






Виконав:                                                                                                   Перевірив:
ст. гр. ПЗПІ-23-9                                                                ст. викладач кафедри ПІ
Пивовар С. Є.                                                                                     Сокорчук І. П.



Харків 2025
ЗМІСТ
1 ІСТОРІЯ ЗМІН	2
2 ЗАВДАННЯ	3
3 ОПИС ВИКОНАНОЇ РОБОТИ	4
3.1 Вступ	4
3.2 Опис проблеми та доцільність рефакторингу	5
3.2.1 Replace Nested Conditional with Guard Clauses – усунення вкладених перевірок	5
3.2.2 Decompose Conditional – розкладання складної умови	8
3.2.3 Replace Temp with Query – заміна тимчасової змінної запитом	10
4 ВИСНОВКИ	14
5	ВИКОРИСТАНІ ДЖЕРЕЛА	15
ДОДАТОК А	16
ДОДАТОК Б	17














1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
20.12.2025
1.0
Створено розділи «Завдання», «Опис виконаної роботи»
2
25.12.2025
1.0
Додано «Висновки», «Використані джерела», додатки А, Б












2 ЗАВДАННЯ
     Навчитися застосовувати основні методи рефакторингу коду на прикладі власних програмних проєктів, уміти виявляти проблеми в структурі коду та покращувати її якість за допомогою відповідних методів. Для цього обрати три методи рефакторингу з книги Мартіна Фаулера та продемонструвати їх на прикладах власного коду до і після змін.
















3 ОПИС ВИКОНАНОЇ РОБОТИ
	3.1 Вступ
	У процесі розробки програмного забезпечення навіть правильно працюючий з точки зору функціональності код може бути надмірно складним, дублювати логіку або містити заплутані умовні конструкції. Такий код важко читати, тестувати та змінювати, що з часом перетворюється на серйозний технічний борг. Рефакторинг дає змогу покращити внутрішню структуру програми без зміни її зовнішньої поведінки, зробивши код більш прозорим і підтримуваним.
   Одним із базових джерел з технік рефакторингу є книга Мартіна Фаулера «Refactoring. Improving the Design of Existing Code», де описано десятки практичних методів покращення коду. У межах цієї роботи я обрав три методи, які часто зустрічаються в реальних проєктах і декілька разів знадобилися мені у власних програмах на C#:
1. Replace Nested Conditional with Guard Clauses – усуває глибоко вкладені конструкції if, замінюючи їх послідовністю простих перевірок-«сторожів» з раннім виходом.
2. Decompose Conditional – розкладає складні логічні умови на окремі зрозумілі методи або змінні, що покращує читабельність бізнес-правил.
3. Replace Temp with Query – замінює тимчасові змінні на окремі методи-запити, які можна повторно використовувати та легше тестувати.
   Обрані методи демонструють різні аспекти рефакторингу: роботу з умовними конструкціями, спрощення логіки прийняття рішень та підвищення рівня абстракції через виділення запитів. Далі кожен метод буде розглянуто за єдиною схемою: опис вихідної проблеми, код до рефакторингу, обґрунтування вибору методу, порядок виконання змін, код після рефакторингу та аналіз отриманих переваг.

     3.2 Опис проблеми та доцільність рефакторингу
     3.2.1 Replace Nested Conditional with Guard Clauses – усунення вкладених перевірок
     Опис проблеми:
     У фрагменті коду з мого курсового проєкту на C# для обробки замовлення в системі «аптечного складу» використовувалась довга послідовність вкладених умов. Метод перевіряв, чи існує замовлення, чи не скасоване воно, чи достатньо товару на складі, чи оплата пройшла успішно тощо. У початковому варіанті всі ці перевірки були оформлені як вкладені if всередині один одного.
   У результаті метод виглядав як «драбина» з кількома рівнями вкладеності. Читати та розуміти таку конструкцію було складно: доводилося постійно відстежувати, яка саме гілка зараз виконується. Будь-яке нове правило (наприклад, перевірка статусу клієнта) ще більше ускладнювало структуру.
   Такий код:
* важко тестувати, бо поведінка залежить від великої кількості умов;
* складно змінювати без ризику порушити одну з гілок;
* погано читається через глибоку вкладеність.
Код до рефакторингу:
1.	// Replace Nested Conditional with Guard Clauses (до рефлакторингу)
2.	public void ProcessOrder(Order order)
3.	{
4.	    if (order != null)
5.	    {
6.	        if (!order.IsCancelled)
7.	        {
8.	            if (order.Items.Any())
9.	            {
10.	                if (_stockService.HasEnoughStock(order))
11.	                {
12.	                    if (_paymentService.Charge(order))
13.	                    {
14.	                        order.Status = OrderStatus.Completed;
15.	                        _notificationService.NotifyCustomer(order);
16.	                    }
17.	                    else
18.	                    {
19.	                        order.Status = OrderStatus.PaymentFailed;
20.	                    }
21.	                }
22.	                else
23.	                {
24.	                    order.Status = OrderStatus.OutOfStock;
25.	                }
26.	            }
27.	        }
28.	    }
29.	}
     Чому Replace Nested Conditional with Guard Clauses оптимальний
     Метод Replace Nested Conditional with Guard Clauses пропонує замінити глибоко вкладені перевірки на послідовність «сторожових» умов на початку методу. Кожен guard clause відразу обробляє некоректний випадок і виконує ранній вихід. Це дозволяє:
* лінійно читати основний позитивний сценарій;
* зменшити глибину вкладеності до одного рівня;
* чітко розділити обробку помилкових та успішних випадків.
     Для даного методу це ідеальне рішення: більшість умов описують «відмову» від обробки замовлення, і саме їх логічно оформити як guard clauses.
     Порядок рефакторингу
1. Визначити всі умови, які описують «погані» сценарії (null, скасоване замовлення, порожній список товарів, відсутність складу, помилка оплати).
2. Для кожної такої умови сформулювати окремий guard clause з раннім виходом з методу або встановленням відповідного статусу.
3. Після перенесення всіх захисних перевірок на початок методу залишити внизу лише основний «щасливий» сценарій.
4. Переконатися, що логіка поведінки не змінилася, а всі статуси замовлення встановлюються так само, як раніше.
     Код після рефакторингу:
1.	// після рефлакторингу
2.	public void ProcessOrder(Order order)
3.	{
4.	    if (order == null)
5.	        return;
6.	
7.	    if (order.IsCancelled)
8.	    {
9.	        order.Status = OrderStatus.Cancelled;
10.	        return;
11.	    }
12.	
13.	    if (!order.Items.Any())
14.	    {
15.	        order.Status = OrderStatus.Empty;
16.	        return;
17.	    }
18.	
19.	    if (!_stockService.HasEnoughStock(order))
20.	    {
21.	        order.Status = OrderStatus.OutOfStock;
22.	        return;
23.	    }
24.	
25.	    if (!_paymentService.Charge(order))
26.	    {
27.	        order.Status = OrderStatus.PaymentFailed;
28.	        return;
29.	    }
30.	
31.	    order.Status = OrderStatus.Completed;
32.	    _notificationService.NotifyCustomer(order);
33.	}

	Переваги
* Метод став коротшим і читабельнішим: основний сценарій видно внизу без зайвої вкладеності.
* Кожен «поганий» випадок обробляється окремим guard clause, що полегшує додавання нових перевірок.
* Зменшено ризик логічних помилок, пов’язаних з пропущеними гілками або невірним розташуванням дужок.
* Легше тестувати окремі сценарії, оскільки кожен guard clause відповідає за конкретну умову.
   3.2.2 Decompose Conditional – розкладання складної умови
	Опис проблеми
	В іншому фрагменті коду, який відповідав за розрахунок знижки для замовлення, використовувалася одна велика складна умова в операторі if. Вона одночасно перевіряла статус користувача, загальну суму замовлення, наявність акційного промокоду та період проведення акції. Умову було важко прочитати з першого разу, а будь-яка зміна бізнес-правил перетворювала її на ще більш заплутаний вираз.
	Такий підхід ускладнює:
* розуміння того, за якої саме комбінації умов надається знижка;
* внесення змін у правила акцій;
* повторне використання частини умов в інших місцях коду.
	Код до рефакторингу:
1.	// Decompose Conditional (до рефлакторингу)
2.	public decimal CalculateDiscount(Order order, Customer customer)
3.	{
4.	    decimal discount = 0m;
5.	
6.	    if (customer.IsVip &&
7.	        order.TotalAmount > 1000 &&
8.	        order.PromoCode == "NEWYEAR" &&
9.	        DateTime.Now >= _promoPeriod.Start &&
10.	        DateTime.Now <= _promoPeriod.End)
11.	    {
12.	        discount = order.TotalAmount * 0.15m;
13.	    }
14.	
15.	    return discount;
16.	}
	Чому Decompose Conditional оптимальний
	Метод Decompose Conditional пропонує винести частини складної умови в окремі методи або булеві змінні з осмисленими назвами. Це дозволяє:
* документувати бізнес-правила через назви методів;
* повторно використовувати простіші умови в інших частинах системи;
* спростити модифікацію правил, змінюючи реалізацію одного методу, а не розбираючись у великому if.
	У нашому випадку природно виділити окремі перевірки: чи активний промоперіод, чи є промокод дійсним, чи підходить клієнт під умови акції.
	Порядок рефакторингу
1. Визначити логічні підумови в існуючому if та дати їм смислові назви.
2. Винести кожну підумову в окремий приватний метод класу або локальну змінну.
3. Замінити складний вираз if на комбінацію викликів цих методів.
4. Переконатися, що жодна частина логіки не втрачена, а тести дають ті самі результати.
	Код після рефакторингу:
1.	// після рефлакторингу
2.	public decimal CalculateDiscount(Order order, Customer customer)
3.	{
4.	    if (!IsCustomerEligible(customer))
5.	        return 0m;
6.	
7.	    if (!IsOrderEligible(order))
8.	        return 0m;
9.	
10.	    if (!IsPromoActive(order))
11.	        return 0m;
12.	
13.	    return order.TotalAmount * 0.15m;
14.	}
15.	
16.	private bool IsCustomerEligible(Customer customer)
17.	{
18.	    return customer.IsVip;
19.	}
20.	
21.	private bool IsOrderEligible(Order order)
22.	{
23.	    return order.TotalAmount > 1000;
24.	}
25.	
26.	private bool IsPromoActive(Order order)
27.	{
28.	    bool hasPromoCode = order.PromoCode == "NEWYEAR";
29.	    bool inPeriod = DateTime.Now >= _promoPeriod.Start &&
30.	                    DateTime.Now <= _promoPeriod.End;
31.	    return hasPromoCode && inPeriod;
32.	}
	Переваги
* Код став самодокументованим: назви методів чітко відображають бізнес-правила надання знижки.
* З’явилася можливість повторно використовувати перевірки, наприклад, IsPromoActive в інших частинах системи.
* Спрощено зміну логіки: щоб змінити умови акції, достатньо відредагувати один допоміжний метод.
* Зменшено когнітивне навантаження: розробник читає послідовність простих перевірок, а не одну гігантську умову.
   3.2.3 Replace Temp with Query – заміна тимчасової змінної запитом
   Опис проблеми
   У методі розрахунку підсумкової суми замовлення я використовував тимчасову змінну total, якій кілька разів присвоював результат обчислення загальної вартості. Така змінна з’являлася не лише в одному методі: подібна логіка розкидана по різних класах, кожного разу трохи відрізняючись. Це призводило до:
* дублювання коду обчислення підсумку замовлення;
* ризику розбіжностей між різними реалізаціями;
* ускладнення тестування – логіку неможливо було перевірити окремо від конкретного методу.
   Код до рефакторингу:
1.	// Replace Temp with Query (до рефлакторингу)
2.	public decimal GetFinalAmount(Order order)
3.	{
4.	    decimal total = 0m;
5.	
6.	    foreach (var item in order.Items)
7.	    {
8.	        total += item.Price * item.Quantity;
9.	    }
10.	
11.	    if (order.Delivery != null)
12.	    {
13.	        total += order.Delivery.Cost;
14.	    }
15.	
16.	    if (order.DiscountPercent > 0)
17.	    {
18.	        total -= total * order.DiscountPercent / 100m;
19.	    }
20.	
21.	    return total;
22.	}
	Чому Replace Temp with Query оптимальний
	Метод Replace Temp with Query пропонує замінити тимчасову змінну окремим методом-запитом, який повертає потрібне значення. Таким чином:
* обчислення зосереджені в одному місці;
* логіку легко повторно використати в інших методах;
* з’являється можливість тестувати цей запит ізольовано.
	У даному випадку логічно виділити окремий метод CalculateOrderBaseTotal, який рахує базову вартість замовлення без знижок, і використовувати його в методі розрахунку фінальної суми.
	Порядок рефакторингу:
1. Визначити вираз або блок коду, результат якого зберігається в тимчасовій змінній.
2. Винести цей вираз у окремий метод, що повертає значення відповідного типу.
3. Замінити використання тимчасової змінної викликом нового методу.
4. Якщо одна й та сама логіка повторюється в інших місцях, замінити її викликами того самого запиту.
5. Додати модульні тести до нового методу, щоб гарантувати коректність обчислень.
	Код після рефакторингу:
1.	// після рефлакторингу
2.	public decimal GetFinalAmount(Order order)
3.	{
4.	    decimal total = CalculateOrderBaseTotal(order);
5.	
6.	    if (order.DiscountPercent > 0)
7.	    {
8.	        total -= total * order.DiscountPercent / 100m;
9.	    }
10.	
11.	    return total;
12.	}
13.	
14. private decimal CalculateOrderBaseTotal(Order order)
15. {
16.     decimal total = 0m;
17.	
18.     foreach (var item in order.Items)
19.	    {
20.	        total += item.Price * item.Quantity;
21.	    }
22.	
23.	 if (order.Delivery != null)
24.	    {
25.	        total += order.Delivery.Cost;
26.	    }
27.	
28.	 return total;
29.}
	Переваги:
* Логіка обчислення базової суми замовлення зосереджена в одному місці й може повторно використовуватися іншими методами.
* Код методу GetFinalAmount став простішим: він відповідає лише за застосування знижки.
* Легше тестувати: можна окремо перевірити CalculateOrderBaseTotal і окремо – логіку знижок.
* Зменшено дублювання коду та ризик розбіжностей при майбутніх змінах.






















4 ВИСНОВКИ
     У ході виконання практичної роботи було розглянуто та застосовано три методи рефакторингу з книги Мартіна Фаулера: Replace Nested Conditional with Guard Clauses, Decompose Conditional та Replace Temp with Query. Аналіз власного коду з навчальних проєктів на C# дозволив виявити типові проблеми: надмірно вкладені конструкції if, громіздкі логічні умови та дублювання обчислень через тимчасові змінні.
     Для кожного методу було наведено фрагменти коду до і після рефакторингу, описано порядок виконання змін та проаналізовано отримані переваги. Застосування guard clauses спростило структуру методів і зробило позитивні сценарії виконання більш очевидними. Розкладання складних умов на окремі методи підвищило читабельність бізнес-логіки та полегшило її зміну. Винесення обчислень у метод-запит зменшило дублювання коду та підвищило можливість повторного використання.
     Отже, виконана робота підтвердила, що систематичний рефакторинг є невід’ємною частиною професійної розробки. Навіть невеликі локальні зміни, виконані за відомими методами, суттєво покращують структуру коду, спрощують його супровід та зменшують технічний борг у майбутніх ітераціях розвитку програмного забезпечення.










5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Microsoft. C# Coding Conventions [Електронний ресурс]. — Режим доступу: https://learn.microsoft.com/dotnet/csharp/fundamentals/coding-style (дата звернення: 20.12.2025).
2. Microsoft. Naming guidelines — .NET documentation [Електронний ресурс]. — Режим доступу: https://learn.microsoft.com/dotnet/standard/design-guidelines/naming-guidelines (дата звернення: 22.12.2025).
3. Албахарі Дж., Албахарі Б. C# 12 in a Nutshell. — O’Reilly Media, 2024. — 1056 с.
4. Мартін Р. Чистий код: Створення, аналіз та рефакторинг за допомогою Agile / пер. з англ. — Київ: Вид-во «Основи», 2021. — 464 c.
5. Fowler M. Refactoring: Improving the Design of Existing Code. 2nd ed. Boston: Addison-Wesley Professional, 2018. – 448 p.
6. Refactoring Guru. Refactoring Techniques [Електронний ресурс]. – Режим доступу: https://refactoring.guru/refactoring (дата звернення: 23.12.2025).













ДОДАТОК А
Відеозапис
     Url відеозапису: https://youtu.be/NdXmWkdPHLM
     Хронологічний опис відеозапису:  
00:00 — Титульний слайд. Представлення студента та теми роботи
00:25 — Що таке рефакторинг та чому він важливий
00:43 — Проблеми, які вирішує рефакторинг
01:20 — Метод 1: Replace Nested Conditional with Guard Clauses. Пояснення проблеми вкладених умов
01:57 — Метод 1: Демонстрація покращеного коду та його переваги
02:28 — Метод 2: Decompose Conditional. Чому великі умови шкідливі
02:52 — Метод 2: Рефакторинг і спрощення логіки. Переваги підходу
03:18 — Метод 3: Replace Temp with Query. Небезпека тимчасових змінних
03:44 — Метод 3: Покращений код. Централізація логіки та спрощення тестування
04:07 — Практичний ефект рефакторингу в моїх навчальних проектів
04:39 — Висновки. Значення рефакторингу в довгостроковій розробці
05:00 — Використані джерела. Завершення виступу











ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний слайд


Рисунок Б.2 – Вступ

Рисунок Б.2 – Що дає рефлакторинг?


Рисунок Б.3 – Метод 1: Replace Nested Conditional with Guard Clauses






Рисунок Б.4 – Метод 1 після рефакторингу


Рисунок Б.5 – Метод 2: Decompose Conditional



Рисунок Б.6 – Метод 2 після рефакторингу


Рисунок Б.7 – Метод 3: Replace Temp with Query


Рисунок Б.8 – Метод 3 після рефакторингу


Рисунок Б.9 – Ефект від рефакторингу



Рисунок Б.10 – Висновки


Рисунок Б.11 – Джерела
2


