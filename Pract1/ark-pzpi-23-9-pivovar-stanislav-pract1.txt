Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Кафедра програмної інженерії



Звіт
з практичної роботи №1 
З дисципліни «Аналіз та рефакторинг коду»
на тему «Правила оформлення програмного коду у C# 
за рекомендаціями Microsoft C# Coding Conventions»






Виконав:                                                                                                   Перевірив:
ст. гр. ПЗПІ-23-9                                                                ст. викладач кафедри ПІ
Пивовар С. Є.                                                                                     Сокорчук І. П.



Харків 2025
ЗМІСТ
1 ІСТОРІЯ ЗМІН	3
2 ЗАВДАННЯ	4
3 ОПИС ВИКОНАНОЇ РОБОТИ	5
3.1 Вступ	5
3.2 Рекомендація 1. Підтримуйте чітку структуру проєкту	5
3.3 Рекомендація 2. Дотримуйтеся принципу єдиної відповідальності	7
3.4 Рекомендація 3. Використовуйте коментарі для логічного поділу коду	9
3.5 Рекомендація 4. Використовуйте єдині правила відступів і форматування коду	10
3.6 Рекомендація 5. Використовуйте узгоджений стиль розміщення дужок	11
3.7 Рекомендація 6. Використовуйте зрозумілі правила іменування	12
3.8 Рекомендація 7. Уникайте «магічних» чисел, використовуйте константи	13
3.9 Рекомендація 8. Використовуйте коментарі лише там, де без них не обійтися	14
3.10 Рекомендація 9. Документуйте публічний код за допомогою XML-коментарів	15
3.11 Рекомендація 10. Використовуйте інструменти перевірки стилю коду	16
3.12 Рекомендація 11. Використовуйте статичний аналіз коду	17
3.13 Рекомендація 12. Застосовуйте тестування під час розробки	18
3.14 Рекомендація 13. Використовуйте інструменти автоматизації для підтримки якості коду	19
4 ВИСНОВКИ	22
5 ВИКОРИСТАНІ ДЖЕРЕЛА	23
ДОДАТОК А	24
ДОДАТОК Б	25




1 ІСТОРІЯ ЗМІН
№
Дата
Версія звіту
Опис змін та виправлень
1
05.12.2025
1.0
Створено розділи «Завдання», «Опис виконаної роботи»
2
12.12.2025
1.0
Додано «Висновки», «Використані джерела», додатки А, Б












2 ЗАВДАННЯ
	Ознайомитися з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду мовою C#. Навчитися застосовувати принципи стилю програмування, рекомендовані Microsoft C# Coding Conventions, на практиці, аналізувати та рефакторити код з метою підвищення його якості, читабельності та продуктивності.

















3 ОПИС ВИКОНАНОЇ РОБОТИ
	3.1 Вступ
	C# — сучасна об’єктно-орієнтована мова програмування, що є основною для  платформи .NET. Вона широко використовується для розробки десктопних, веб-, мобільних та хмарних застосунків. Гнучкість мови, велика стандартна бібліотека та активна екосистема інструментів роблять C# базовим інструментом для розробників .NET.
     Разом з тим, без єдиних правил оформлення коду великі проєкти стають важкочитаними, важкими для супроводу та рефакторингу. Для уникнення цих проблем застосовуються code conventions — стандартизовані правила стилю програмування, що регламентують структуру проєкту, форматування, правила іменування, коментування та документування коду.
     У даній роботі розглянуто основні правила оформлення програмного коду мовою C# відповідно до рекомендацій Microsoft C# Coding Conventions. Наведено приклади правильних і неправильних фрагментів коду, а також показано, як дотримання стандартів стилю позитивно впливає на якість і підтримуваність програмного забезпечення.
     3.2 Рекомендація 1. Підтримуйте чітку структуру проєкту
     Рекомендація полягає в тому, щоб організовувати C#-рішення за шарами та функціональними областями: окремо рівень представлення (UI/API), доменна логіка, доступ до даних, тести, а всередині проєктів – групування файлів у папки за призначенням (Models, Services, Controllers тощо).
Приклад поганого та гарного коду відповідно до правил:
       1.	// 3.2 Рекомендація 1. Підтримуйте чітку структуру проєкту
       2.	// Поганий приклад
       3.	// Увесь код звалено в один проєкт і один клас
       4.	using App.Core.Services.App.Infrastructure.Repositories;
       5.	
       6.	public class App
       7.	{
       8.	    // UI
       9.	    public void RenderMainPage() { /* ... */ }
       10.	
       11.	    // Бізнес-логіка
       12.	    public void CreateOrder(User user, List<Product> products)
       13.	    {
       14.	        // валідація, розрахунок, збереження, e-mail – все тут
       15.	    }
       16.	
       17.	    // Доступ до БД
       18.	    public void SaveToDatabase(object entity)
       19.	    {
       20.	        // прямий SQL тут
       21.	    }
       22.	}
       23.	// -------------------------------------
       24.	// Гарний приклад коду
       25.	// Шари розділені, відповідальність розмежована
       26.	// Рівень доменної логіки
       27.	namespace App.Core.Services;
       28.	
       29.	public class OrderService
       30.	{
       31.	    private readonly IOrderRepository _orders;
       32.	    private readonly IEmailSender _emailSender;
       33.	
       34.	    public OrderService(IOrderRepository orders, IEmailSender emailSender)
       35.	    {
       36.	        _orders = orders;
       37.	        _emailSender = emailSender;
       38.	    }
       39.	
       40.	    public void CreateOrder(User user, IReadOnlyCollection<Product> products)
       41.	    {
       42.	        var order = Order.Create(user, products);
       43.	        _orders.Save(order);
       44.	        _emailSender.SendOrderCreated(user, order);
       45.	    }
       46.	}
       47.	
       48.	// Рівень доступу до даних
       49.	namespace App.Infrastructure.Repositories;
       50.	
       51.	public class OrderRepository : IOrderRepository
       52.	{
       53.	    public void Save(Order order)
       54.	    {
       55.	        // збереження через ORM
       56.	    }
       57.	}
       58.	
       59.	// Рівень веб-інтерфейсу
       60.	namespace App.Web.Controllers;
       61.	
       62.	public class OrdersController : Controller
       63.	{
       64.	    private readonly OrderService _orderService;
       65.	
       66.	    public OrdersController(OrderService orderService)
       67.	    {
       68.	        _orderService = orderService;
       69.	    }
       70.	
       71.	    public IActionResult Create(CreateOrderDto dto)
       72.	    {
       73.	        // мапінг DTO -> домен, виклик сервісу
       74.	        return RedirectToAction("Index");
       75.	    }
       76.	}
       77.	// -------------------------------------
     Переваги дотримання правила:
1. Забезпечується зрозуміла навігація між компонентами C#-рішення.
2. Підвищується якість командної взаємодії: усі розробники орієнтуються на спільну архітектуру.
3. Зменшується ризик дублювання логіки та змішування бізнес-коду з інфраструктурним.
4. Спрощується масштабування та виділення частин застосунку в окремі сервіси або бібліотеки.
     Наслідки недотримання:
     Невпорядкована структура призводить до хаотичного розташування файлів, поєднання різних обов’язків в одному класі та ускладнює входження нових розробників у проєкт. З часом це робить підтримку й розвиток системи дорогими та ризикованими.
     3.3 Рекомендація 2. Дотримуйтеся принципу єдиної відповідальності
     Рекомендація означає, що кожен клас, інтерфейс і метод у C# повинен мати лише одну чітку відповідальність: окремо бізнес-логіка, окремо збереження в базу даних, окремо відправлення повідомлень і логування, без поєднання всього в одному «бог-класі».
1.	// 3.3 Рекомендація 2. Дотримуйтеся принципу єдиної відповідальності
2.	// Поганий приклад
3.	public class UserManager
4.	{
5.	    public void RegisterUser(User user)
6.	    {
7.	        // бізнес-логіка
8.	        // валідація
9.	        // збереження в БД
10.	        // надсилання e-mail
11.	        // логування
12.	    }
13.	}
14.	// -------------------------------------
15.	// Гарний приклад коду
16.	public class UserService
17.	{
18.	    private readonly IUserRepository _users;
19.	    private readonly IEmailSender _emailSender;
20.	
21.	    public UserService(IUserRepository users, IEmailSender emailSender)
22.	    {
23.	        _users = users;
24.	        _emailSender = emailSender;
25.	    }
26.	
27.	    public void RegisterUser(User user)
28.	    {
29.	        // бізнес-логіка та валідація
30.	        _users.Save(user);
31.	        _emailSender.SendWelcome(user);
32.	    }
33.	}
34.	
35.	public interface IUserRepository
36.	{
37.	    void Save(User user);
38.	}
39.	
40.	public interface IEmailSender
41.	{
42.	    void SendWelcome(User user);
43.	}
44.	// -------------------------------------
	Переваги дотримання правила:
1. Код стає модульним: кожен клас виконує обмежений набір завдань.
2. Спрощується модульне тестування: залежності можна підміняти мок-об’єктами.
3. Зміни в одному аспекті логіки мінімально впливають на інші частини системи.
4. Зменшується кількість прихованих зв’язків, знижується ризик «ланцюгових» помилок.
     Наслідки недотримання:
     Поєднання декількох відповідальностей в одному класі призводить до зростання його розміру й складності. Будь-яка правка в такому класі потенційно ламає кілька сценаріїв, ускладнюється тестування, а технічний борг швидко накопичується.

	3.4 Рекомендація 3. Використовуйте коментарі для логічного поділу коду
     Рекомендація передбачає використання коментарів не для опису очевидних інструкцій, а для виділення логічних етапів обробки, пояснення нетривіальної бізнес-логіки та акцентування важливих граничних випадків у складних методах.
1.	// 3.4 Рекомендація 3. Використовуйте коментарі для логічного поділу коду
2.	// Поганий приклад
3.	public void Process()
4.	    {
5.	        // збільшуємо лічильник
6.	        count++;
7.	
8.	        // проходимо по елементах
9.	        foreach (var item in items)
10.	        {
11.	            // виводимо в консоль
12.	            Console.WriteLine(item);
13.	        }
14.	    }
15.	// -------------------------------------
16.	// Гарний приклад коду
17.	public void ProcessActiveUsers()
18.	{
19.	    // 1. Отримуємо активних користувачів за останні 30 днів
20.	    var activeUsers = _userRepository.GetActiveUsers(days: 30);
21.	
22.	    // 2. Відправляємо сповіщення
23.	    foreach (var user in activeUsers)
24.	    {
25.	        _notificationService.Notify(user);
26.	    }
27.	
28.	    // 3. Формуємо звіт за результатами розсилки
29.	    _reportService.GenerateActiveUsersReport(activeUsers);
30.	}
31.	// -------------------------------------
   Переваги дотримання правила:
1. Коментарі допомагають швидко зрозуміти загальну структуру складного методу.
2. Новим розробникам легше орієнтуватися в бізнес-логіці без глибокого аналізу кожного рядка.
3. Акценти на ключових етапах зменшують ризик помилок під час змін і рефакторингу.
   Наслідки недотримання:
   Відсутність змістових коментарів у складному коді робить методи важкими для сприйняття, а надлишок тривіальних коментарів створює інформаційний шум. Такі коментарі рідко оновлюються, швидко застарівають і можуть вводити в оману, ускладнюючи підтримку застосунку.
   3.5 Рекомендація 4. Використовуйте єдині правила відступів і форматування коду
   Усі файли коду у C# мають форматуватися узгоджено: відступи — 4 пробіли, пробіли навколо операторів, дужки — завжди на наступному рядку після заголовка блоку за стандартом, а довжина рядка не повинна бути надто великою (рекомендовано до 120 символів). Узгоджений стиль значно підвищує читабельність.
1.	// 3.5 Рекомендація 4. Використовуйте єдині правила відступів і форматування
2.	// Поганий приклад
3.	public void Print(){
4.	Console.WriteLine("Start");
5.	if(true){
6.	Console.WriteLine("Done");}
7.	}
8.	// -------------------------------------
9.	// Гарний приклад коду
10.	public void Print()
11.	{
12.	    Console.WriteLine("Start");
13.	
14.	    if (true)
15.	    {
16.	        Console.WriteLine("Done");
17.	    }
18.	}
19. // -------------------------------------
	
   Переваги дотримання правила:
1. Код читається однаково в будь-якій IDE або при перегляді у Git.
2. Під час командної роботи зменшується кількість конфліктів у Pull Request через різні стилі.
3. Полегшується огляд коду на рев’ю, швидше виявляються логічні помилки.
   Наслідки недотримання:
   Код виглядає неоднорідним, важче сприймається та аналізується. Часто виникають конфлікти під час злиття гілок через різні варіанти вирівнювання. Розробники починають витрачати час на виправлення стилю замість того, щоб працювати над логікою.
   3.6 Рекомендація 5. Використовуйте узгоджений стиль розміщення дужок
   У C# рекомендовано використовувати один стиль дужок на весь проєкт, найчастіше – K&R: відкрита фігурна дужка на новому рядку після оголошення блоку, закрита – на своєму рядку, чітко структуруючи логічні блоки й видимі рівні вкладеності.
1.	// 3.6 Рекомендація 5. Використовуйте узгоджений стиль дужок
2.	// Поганий приклад
3.	if (isValid)
4.	{
5.	    DoWork();
6.	}
7.	else
8.	{
9.	    DoFallback();}
10. // -------------------------------------
11. // Гарний приклад коду
12.	if (isValid)
13.	{
14.	    DoWork();
15.	}
16.	else
17.	{
18.	    DoFallback();
19.	}
20. // -------------------------------------

   Переваги дотримання правила:
1. Структура коду сприймається візуально: легко визначити вкладеність і межі блоків.
2. Зменшується ризик пропущених або зайвих дужок при редагуванні.
3. Команда швидше орієнтується в коді, не відволікаючись на «читання стилю».
   Наслідки недотримання:
   «Стрибки» стилю дужок збивають з пантелику, ускладнюють налагодження і візуальний аналіз. Будь-яке форматування в безладному вигляді різко погіршує сприйняття великого коду та сприяє механічним помилкам.
   3.7 Рекомендація 6. Використовуйте зрозумілі правила іменування
   У C# закріпилися такі конвенції: PascalCase – для класів, властивостей, методів; camelCase – для локальних змінних і параметрів; інтерфейси починаються з літери «I». Імена повинні передавати призначення сутності, уникаючи абстрактних скорочень та загальних назв на кшталт data, calc, obj.
1.	// 3.7 Рекомендація 6. Використовуйте зрозумілі правила іменування
2.	// Поганий приклад
3.	int a = 10;
4.	string str1 = "name";
5.	
6.	public void Do(int x)
7.	{
8.	    Console.WriteLine(a + x);
9.	}
10. // -------------------------------------
11. // Гарний приклад коду
12.	private const int DefaultOffset = 10;
13.	
14.	public void PrintSum(int value)
15.	{
16.	    Console.WriteLine(DefaultOffset + value);
17.	}
18.	
19.	string userName = "Alex";
20. // -------------------------------------

   Переваги дотримання правила:
1. Назва сама пояснює сенс змінної або методу, зменшуючи потребу в коментарях.
2. Код стає набагато читабельнішим для будь-якого розробника в команді.
3. Відстеження поведінки програми стає швидшим і простішим.
   Наслідки недотримання:
   Розробники витрачають час на здогадки про «що таке a або str1», складно уточнювати й підтримувати логіку. При розширенні проєкту з’являються помилки через неоднозначні назви, що безпосередньо б’є по продуктивності командної роботи.
	3.8 Рекомендація 7. Уникайте «магічних» чисел, використовуйте константи
	Рекомендація полягає в тому, щоб не залишати в коді «магічні» числові значення без пояснення їхнього значення, а замінювати їх на іменовані константи або параметри конфігурації, які явно відображають сенс числа в бізнес-логіці.
// 3.8 Рекомендація 7. Уникайте «магічних» чисел і використовуйте константи
// Поганий приклад
if (age > 18)
{
    discount = 0.1m;
}
// -------------------------------------
// Гарний приклад коду
private const int AdultAge = 18;
private const decimal AdultDiscount = 0.10m;

if (age > AdultAge)
{
    discount = AdultDiscount;
}
// -------------------------------------

   Переваги дотримання правила:
1. Код стає самодокументованим: з імені константи видно її роль у логіці.
2. Зміна бізнес-правил (порогу віку, розміру знижки) виконується в одному місці.
3. Зменшується ризик неузгоджених значень, коли одне і те саме число копіюється в декількох місцях.
   Наслідки недотримання:
   Велика кількість «магічних» чисел робить код схожим на набір випадкових констант, які важко інтерпретувати. Будь-яка зміна правила вимагає пошуку всіх входжень числа, що створює ризик помилок і непослідовної поведінки системи.
   3.9 Рекомендація 8. Використовуйте коментарі лише там, де без них не обійтися
   Рекомендація підкреслює, що основна зрозумілість коду досягається за рахунок якісних імен змінних, методів і чіткої структури, а не за рахунок великої кількості коментарів. Коментарі мають пояснювати незвичні рішення або складні алгоритми, а не те, що і так очевидно з коду.
1.	// 3.9 Рекомендація 8. Використовуйте коментарі лише там, де це дійсно необхідно
2.	// Поганий приклад
3.	// додаємо до списку
4.	users.Add(user);
5.	
6.	// виводимо кількість
7.	Console.WriteLine(users.Count);
8.	// -------------------------------------
9.	// Гарний приклад коду
10. // Обчислення середнього значення зважених показників
11. public double GetWeightedAverage(IEnumerable<Metric> metrics)
12.	{
13.	    double totalWeight = metrics.Sum(m => m.Weight);
14.	
15.	    return metrics.Sum(m => m.Value * m.Weight) / totalWeight;
16.	}
17. // -------------------------------------

   Переваги дотримання правила:
1. Коментарі зберігають високу цінність, оскільки використовуються лише там, де потрібне додаткове пояснення.
2. Код легше підтримувати: менше шансів, що застарілий коментар суперечитиме фактичній реалізації.
3. Розробники концентруються на покращенні самої структури коду, а не «маскуванні» проблем коментарями.
   Наслідки недотримання:
   Перевантаження коду тривіальними чи застарілими коментарями створює інформаційний шум. Розробники перестають довіряти коментарям, витрачають час на з’ясування, що є правдою: коментар чи реальний код, що ускладнює налагодження та рефакторинг.
   3.10 Рекомендація 9. Документуйте публічний код за допомогою XML-коментарів
   Рекомендація стосується використання XML-коментарів /// для публічних класів, методів і властивостей, які використовуються іншими частинами системи або зовнішніми споживачами. Такі коментарі описують призначення методу, параметри та значення, яке він повертає, і автоматично підхоплюються середовищем розробки.
1.	// 3.10 Рекомендація 9. Документуйте код за допомогою XML-коментарів
2.	// Поганий приклад
3.	public decimal CalculateDiscountedPrice(decimal price, int discountPercent)
4.	{5.	    return price - price * discountPercent / 100m;
6.	}
7.	// -------------------------------------
8.	// Гарний приклад коду
9.	/// <summary>
10. /// Обчислює ціну з урахуванням знижки.
11. /// </summary>
12. /// <param name="price">Початкова ціна.</param>
13. /// <param name="discountPercent">Розмір знижки у відсотках.</param>
14. /// <returns>Ціна після застосування знижки.</returns>
15. public decimal CalculateDiscountedPrice(decimal price, int discountPercent)
16.	{
17.	    return price - price * discountPercent / 100m;
18.	}
19. // --------------------------------------

   Переваги дотримання правила:
1. Інші розробники отримують зрозумілі підказки в IDE щодо призначення методу, його параметрів та результату.
2. Є можливість автоматично генерувати документацію для бібліотек і публічних API.
3. Зменшується кількість помилок через неправильне використання методів та класів.
   Наслідки недотримання:
   Використання публічних методів стає менш очевидним: розробники змушені відкривати реалізацію, щоб зрозуміти, які значення можна передати в параметри і що вони означають. Це сповільнює роботу команди і збільшує ризик некоректного застосування API.
   3.11 Рекомендація 10. Використовуйте інструменти перевірки стилю коду
   Рекомендація полягає в тому, щоб підключати автоматичні інструменти контролю стилю (StyleCop Analyzers, Roslyn Analyzers, форматер Visual Studio), які перевіряють відповідність коду стандартам і пропонують виправлення, попереджають про потенційні помилки й уніфікують стиль усієї команди.
1.	// 3.11 Рекомендація 10. Використовуйте інструменти перевірки стилю коду
2.	// Поганий приклад
3.	public class user
4.	{
5.	    public string name;
6.	    public void print()
7.	    {
8.	        Console.WriteLine(name);
9.	    }
10.	}
11. // -------------------------------------
12. // Гарний приклад коду
13. public class User
14. {
15.	public string Name { get; set; }
16.	
17.	public void Print()
18.	{
19.	    Console.WriteLine(Name);
20.	}
21. }

   Переваги дотримання правила:
   1. Менше дрібних зауважень на рев’ю –  автоматичні правила перевіряють це замість людей.
   2. Нові учасники команди відразу бачать встановлені стандарти оформлення.
   3.   Знижується ризик пропустити синтаксичні або структурні помилки на ранніх етапах.
   Наслідки недотримання:
   Якщо покладатися лише на «уважність розробника», стиль постійно роз’їжджається. Команда витрачає час на суперечки щодо форматування, а накопичення дрібних недоліків ускладнює підтримку та уніфікацію коду.
   3.12 Рекомендація 11. Використовуйте статичний аналіз коду
   Рекомендація означає застосування інструментів статичного аналізу (SonarQube, вбудовані Roslyn-аналізатори), які перевіряють логічні помилки, потенційні проблеми продуктивності, безпеки та «погані запахи коду» без запуску програми.
1.	// 3.12 Рекомендація 11. Використовуйте статичний аналіз коду
2.	// Поганий приклад
3.	public int Divide(int a, int b)
4.	{
5.	    return a / b; // можливий поділ на нуль
6.	}
7.	// Гарний приклад коду
8.	public int Divide(int a, int b)
9.	{
10.	    if (b == 0)
11.	    {
12.	        throw new DivideByZeroException("Denominator must not be zero.");
13.	    }
14.	
15.	    return a / b;
16.	}
17.	// -------------------------------------

Переваги дотримання правила:
1. Помилки виявляються до запуску програми, що значно знижує вартість їх виправлення.
2. Покращується стабільність і надійність системи завдяки виправленню прихованих дефектів.
3. Підвищується рівень безпеки — аналізатори знаходять небезпечні конструкції.
Наслідки недотримання:
Помилки доходять до етапу інтеграції або навіть користувача, що збільшує ризики й витрати на підтримку. Деякі дефекти, особливо пов’язані з безпекою (SQL-ін’єкції, переповнення буфера), можуть залишитися непоміченими.
   3.13 Рекомендація 12. Застосовуйте тестування під час розробки
   Рекомендація передбачає створення модульних тестів (наприклад, xUnit або NUnit), щоб переконатися в коректності реалізації методів, зменшити ризик регресій і мати впевненість у стабільності поведінки коду навіть після змін і рефакторингу.
1.	// 3.13 Рекомендація 12. Застосовуйте тестування під час розробки
2.	// Поганий приклад (метод без тестів)
3.	public int GetUserAge(User user)
4.	{
5.	    if (user == null)
6.	    {
7.	        return -1;
8.	    }
9.	
10.	    return user.Age;
11.	}
12.	// -------------------------------------
13.	// Гарний приклад коду (з тестом)
14.	public int GetUserAge(User user)
15.	{
16.	    if (user == null)
17.	    {
18.	        return -1;
19.	    }
20.	
21.	    return user.Age;
22.	}
23.	
24.	// xUnit-тест
25.	[Fact]
26.	public void GetUserAge_ReturnsAge_ForValidUser()
27.	{
28.	    var user = new User { Age = 25 };
29.	    var result = GetUserAge(user);
30.	
31.	    Assert.Equal(25, result);
32.	}
33.	// -------------------------------------

Переваги дотримання правила:
1. Можна впевнено змінювати код, маючи гарантію, що поведінка залишилась правильною.
2. Тести стають живою документацією: показують очікувану роботу методу.
3. Помилки виявляються одразу під час розробки, а не пізніше у продакшні.
Наслідки недотримання:
	Будь-яке оновлення або рефакторинг може зламати програму непомітно. Дефекти накопичуються, а виявлення їх стає дорогим і тривалим, оскільки тестування перекладається на ручну перевірку або на користувачів.
	3.14 Рекомендація 13. Використовуйте інструменти автоматизації для підтримки якості коду
	Ця рекомендація включає використання CI/CD (GitHub Actions, GitLab CI, Azure DevOps) і Git Hooks для автоматичного запуску тестів, статичного аналізу та перевірки стилю на кожному коміті або pull request. Це запобігає потраплянню «битого» коду в основну гілку.
	
1. // 3.14 Рекомендація 13. Використовуйте інструменти автоматизації
2. // Поганий приклад
3. 
4. // Розробник ніколи не запускає тести локально і не має CI
5. // Тести існують, але ними ніхто не користується.
6. // -------------------------------------
7. // Гарний приклад коду (умовний фрагмент YAML для GitHub Actions)
8. 
9. /*
10. name: .NET CI
11. 
12. on:
13. push:
14. branches: [ "main" ]
15. pull_request:
16. branches: [ "main" ]
17. 
18. jobs:
19. build:
20. runs-on: ubuntu-latest
21. steps:
22. - uses: actions/checkout@v4
23. - name: Setup .NET
24. uses: actions/setup-dotnet@v4
25. with:
26. dotnet-version: 8.0.x
27. - name: Restore
28. run: dotnet restore
29. - name: Build
30. run: dotnet build --no-restore
31. - name: Test
32. run: dotnet test --no-build --verbosity normal
33. */
34. 

Переваги дотримання правила:
1. Проблеми виявляються до додавання коду в основну гілку.
2. Зменшується навантаження на код-рев’ю — інструменти ловлять більшість дрібних недоліків.
3. Команда працює швидше й стабільніше: автоматизація підвищує якість випусків.
Наслідки недотримання:
	Без автоматизації помилки, що легко виявити, потрапляють до продакшну, час рев’ю витрачається на форматування, а не аналіз логіки, а підтримка системи стає дорожчою й ризикованішою.
























4 ВИСНОВКИ
     У ході виконання практичного завдання було опрацьовано основні правила оформлення програмного коду мовою C# відповідно до рекомендацій Microsoft C# Coding Conventions. Розглянуті принципи стосувалися структурування рішень та проєктів, дотримання єдиних стилістичних вимог до форматування й розміщення дужок, застосування зрозумілих конвенцій іменування, раціонального використання коментарів та XML-документації для публічних складових API.
     Було встановлено, що дотримання узгоджених правил оформлення коду підвищує читабельність програм, полегшує адаптацію нових учасників команди, сприяє ефективному проведенню рев’ю та рефакторингу, а також запобігає накопиченню технічного боргу. Окрема увага була приділена інструментам автоматичної перевірки стилю, статичного аналізу та автоматизації контролю якості коду, що є ключовими практиками у сучасній розробці програмного забезпечення на платформі .NET.
     Таким чином, практична робота дала можливість сформувати розуміння важливості стандартизованого стилю програмування та набути навичок його застосування на прикладах рефакторингу фрагментів коду C#. Дотримання цих рекомендацій сприяє створенню підтримуваного, масштабованого та надійного програмного забезпечення.









5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Microsoft. C# Coding Conventions [Електронний ресурс]. — Режим доступу: https://learn.microsoft.com/dotnet/csharp/fundamentals/coding-style (дата звернення: 01.12.2025).
2. Microsoft. Naming guidelines — .NET documentation [Електронний ресурс]. — Режим доступу: https://learn.microsoft.com/dotnet/standard/design-guidelines/naming-guidelines (дата звернення: 02.12.2025).
3. Албахарі Дж., Албахарі Б. C# 12 in a Nutshell. — O’Reilly Media, 2024. — 1056 с.
4. Мартін Р. Чистий код: Створення, аналіз та рефакторинг за допомогою Agile / пер. з англ. — Київ: Вид-во «Основи», 2021. — 464 c.
5. Microsoft. XML documentation comments [Електронний ресурс]. — Режим доступу: https://learn.microsoft.com/dotnet/csharp/language-reference/xmldoc (дата звернення: 10.12.2025).
6. StyleCop Analyzers Documentation [Електронний ресурс]. — Режим доступу: https://github.com/DotNetAnalyzers/StyleCopAnalyzers (дата звернення: 09.12.2025).
7. SonarQube Documentation [Електронний ресурс]. — Режим доступу: https://docs.sonarsource.com/sonarqube (дата звернення: 08.12.2025).







ДОДАТОК А
Відеозапис
     Url відеозапису: https://youtu.be/i5-HcKzxtzI
     Хронологічний опис відеозапису:
Вступ – 00:30
Наслідки дотримання та недотримання код-конвенцій – 01:04
Підтримуйте чітку структуру проєкту – 01:37
Дотримуйтесь принципу єдиної відповідальності – 02:18
Використовуйте коментарі для логічного поділу коду – 02:54
Використовуйте єдині правила відступів і форматування коду – 03:31
Використовуйте узгоджений стиль розміщення дужок – 04:10
Використовуйте зрозумілі та послідовні правила іменування – 04:48
Уникайте «магічних» чисел і використовуйте константи – 05:26
Використовуйте коментарі лише там, де це дійсно необхідно – 06:09
Документуйте публічні методи та класи за допомогою XML-коментарів – 06:42
Використовуйте інструменти перевірки стилю коду – 07:17
Використовуйте статичний аналіз для виявлення потенційних помилок – 07:55
Застосовуйте тестування під час розробки – 08:32
Використовуйте інструменти автоматизації для перевірки якості коду (CI/CD) – 09:06
Висновки – 09:35
Використані джерела – 10:06





ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний слайд


Рисунок Б.2 – Вступ

Рисунок Б.2 – Наслідки дотримання та недотримання код-конвенцій


Рисунок Б.3 – Рекомендація 1. Структура проєкту

Рисунок Б.4 – Рекомендація 2. Дотримуйтеся принципу єдиної відповідальності


Рисунок Б.5 – Рекомендація 3. Використовуйте коментарі для логічного поділу коду


Рисунок Б.6 – Рекомендація 4. Використовуйте єдині правила відступів і форматування коду


Рисунок Б.7 – Рекомендація 5. Використовуйте узгоджений стиль дужок


Рисунок Б.8 – Рекомендація 6. Використовуйте зрозумілі правила іменування

Рисунок Б.9 – Рекомендація 7. Уникайте «магічних» чисел і використовуйте константи



Рисунок Б.10 – Рекомендація 8. Використовуйте коментарі лише там, де це дійсно необхідно


Рисунок Б.11 – Рекомендація 9. Документуйте код за допомогою XML-коментарів


Рисунок Б.12 – Рекомендація 10. Використовуйте інструменти перевірки стилю коду


Рисунок Б.13 – Рекомендація 11. Використовуйте статичний аналіз коду


Рисунок Б.14 – Рекомендація 12. Застосовуйте тестування під час розробки


Рисунок Б.15 – Рекомендація 13. Використовуйте інструменти автоматизації для перевірки якості коду


Рисунок Б.16 – Висновки


Рисунок Б.11 – Використані джерела


2


